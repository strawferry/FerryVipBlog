<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactNative 仿造 ofo 共享单车快速开发的app]]></title>
    <url>%2F2017%2F05%2F20%2FReactNative%E4%BB%BF%E9%80%A0ofo%20%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E7%9A%84app%2F</url>
    <content type="text"><![CDATA[ofo ReactNative 仿版(主要是做 iOS版本)原因之前一直想做个 ReactNative 关于地图相关的 demo ,然后近两天在群里看见有人发的 RN 做的 ofo 共享单车的仿版(主要是针对安卓的),就想着乘着这几天活不多,也做一个,用下最新的 RN 版本(0.44),本来是想体验一下一些新特性的,目前主要还是在40以下做项目,主要考虑版本兼容,不过目前看也差不多可以升级40以上了,至于这个 ofo 仿版还是有很多没有用到新的特性的东西,好了话不多说,上效果图; 效果图 iOS 安卓 package.json12345678910"native-base": "^2.1.3","react": "16.0.0-alpha.6","react-native": "0.44.0","react-native-blur": "^3.0.0-alpha","react-native-camera": "^0.8.0","react-native-maps": "^0.15.0","react-native-scrollable-tab-view": "^0.6.6","react-native-share": "^1.0.20","react-native-simple-toast": "^0.0.6","react-navigation": "^1.0.0-beta.9" 主要用到的一些依赖,时间比较匆忙,有些没有兼容两个平台,特别是安卓,地图的没有做到很详细; 项目怎么跑起来 把本仓库下载或者克隆下来; Github 地址: https://github.com/strawferry/reactnativeofo 前往仓库目录,终端执行 npm install 或者 yarn; 终端执行 react-native link,链接相关的依赖; 然后运行项目; 感谢当时在群里看到这个仓库,发现做的还不错,但是主要是针对安卓的,当时 iOS 适配比较差,就想着搞一个出来;React Native 仿 ofo 共享单车 App http://www.marno.cn]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-webpack脚手架]]></title>
    <url>%2F2017%2F05%2F08%2Freact-webpack%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[react-webpack 脚手架[TOC] 基于 webpack2 react 最新版; 项目使用的 npm 包;package.json 12 1npm i -D babel-core babel-loader babel-preset-es2015 babel-preset-stage-0 babel-preset-react css-loader img-loader file-loader html-loader postcss-loader style-loader url-loader webpack webpack-dev-server html-webpack-plugin clean-webpack-plugin babel-plugin-import bundle-loader extract-text-webpack-plugin optimize-css-assets-webpack-plugin postcss-loader postcss-pxtorem precss 1npm i -S react react-dom antd antd-mobile react-router react-router-dom 1npm i -D redux react-redux react-router-redux react-thunk]]></content>
  </entry>
  <entry>
    <title><![CDATA[react学习]]></title>
    <url>%2F2017%2F04%2F27%2Freact%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[react之前做过 ReactNative 开发,所以 react 的基本的概念和生命周期基本都是一样,目前缺少的知识是一些 html css 方面的知识,布局方面和之前的 RN 布局稍微有点不一样,还有就是 webpack 的脚手架搭建,目前是 webpack 2.3 目前的大多数教程还处于 webpack 1.0 的,所以还需要多点的积累; 补充 html css 网页布局; webpack 脚手架构建; 做个基本小项目出来; react-router 用于控制路由和页面跳转的组件,包含 web 和 ReactNative 的,需要多加理解,然后运用到项目里面; firebase不错的一个云服务,可以实现多端同时使用,还可以部署网页的文件到线上,感觉还不错,可以深入学习点; TODO react 知识补充;(04-24–04-26 done) html css;(一周预计在: 05-02–05-10) 实际项目;(在5月份内做完,)]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用 Travis CI 自动部署 hexo 博客到 GitHub Pages 上]]></title>
    <url>%2F2017%2F04%2F16%2F%E5%88%A9%E7%94%A8%20Travis%20CL%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20hexo%20%E5%8D%9A%E5%AE%A2%E5%88%B0%20GitHub%20Pages%20%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[最近一直在看一些关于持续集成的东西,持续集成会对整个项目的敏捷开发有很大的帮助; 了解过 jenkins, 功能非常强大,但是在做 iOS 持续集成必须在一台 Mac 系统下,后面通过了解和别人介绍,认识到了今天的主角 Travis CI; hexo虽然可以方便地部署github静态博客，但是仅仅是把最终生成的html保存在repository中，像原始的Markdown文件，hexo配置文件，主题配置文件，修改文件都仅仅是保存在本地。这样不利于保存，也无法查看每篇博客的修改历史。更重要的是无法做到跨平台，也不易于多人写作。 想法是每次写博客，只需要push md文件及博客所需的资源文件即可。Travis CI持续集成tool可以满足此需求。 Travis CI 目前主要是和 GitHub 一起使用,所以今天的例子就以 hexo 博客的每次 push 触发 Travis CI 自动部署到 GitHub 的 Pages 上; 1. 思路 2. 具体实现2.1 首先需要在 GitHub 上面创建一个仓库(或者已有) 以新建仓库为例 2.2 生成 Personal Access tokens 为后续的功能生成的 token 登录github, settings -&gt; Personal access tokens -&gt; Generate new token 填写token description，比如叫 travis.并勾选上授予的权限，比如我勾选的是repo和gist，然后create. 将产生的token串复制保留下来，后面会使用到,如果丢失，只能重新产生。 2.3 travis-ci 设置登录 travis-ci 网站,利用 GitHub 账号登录; 同步 GitHub 仓库 选取刚才创建的仓库并打开 添加刚才的 token 作为全局变量 2.4 hexo 博客设置基本的 hexo 命令 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 进入 blog 所在的文件夹下，新建 .travis.yml 文件，并添加以下内容 1234567891011121314151617181920212223242526272829303132333435# 使用语言language: node_js# node版本node_js: stable# 设置只监听哪个分支branches: only: - source# 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除cache: apt: true yarn: true directories: - node_modules# tarvis生命周期执行顺序详见官网文档before_install:- git config --global user.name "name"- git config --global user.email "mmail@mail.com"# 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除- curl -o- -L https://yarnpkg.com/install.sh | bash- export PATH=$HOME/.yarn/bin:$PATH- npm install -g hexo-cliinstall:# 不用yarn的话这里改成 npm i 即可- yarnscript:- hexo clean- hexo generateafter_success:- cd ./public- git init- git add --all .- git commit -m "Travis CI Auto Builder"# 这里的 REPO_TOKEN 即之前在 travis 项目的环境变量里添加的- git push --quiet --force https://$REPO_TOKEN@git@github.com/strawferry/FerryVipBlog.git master 然后，准备 push 该项目到 github ，如果是新项目可参照下面的git指令 12345678git init# 添加自己的项目git remote add origin git@github.com:strawferry/travis.git# 新建并切换分支git checkout --orphan sourcegit add -Agit commit -m "init repo"git push 2.5 发布博客文章12345前往 source 分支下:hexo new title // 1. 新建文章;2. 使用 markdown 软件或者 vim 直接编写文章内容,并保存文件;3. 把目前分支的内容变化提交到 git 线上仓库;4. 接着就等待 travis-ci 自动部署到 pages 上; 这样你的博客就已经成功部署到 pages 上面了 总结这个是一个简单的对 travis-ci 的入门,这样能够给我们提供不少的事,持续集成能够给开发带来极大的便利,让程序员不做一些重复的事情,提高效率;]]></content>
  </entry>
  <entry>
    <title><![CDATA[混合app集成热更新]]></title>
    <url>%2F2017%2F02%2F22%2Fhybrid-app-codepush%2F</url>
    <content type="text"><![CDATA[混合app集成热更新原因是因为之前做的都是纯 rn 项目,偶尔接入原生,所以 codepush 比较好集成. 有一次在想如果原本是原生的项目,后面只是引入 rn 作为一些基础模块,这样的更新要如何做,也就有了这篇文章(技术很早实现了,博客因为懒后面盆友需要,拖了现在才写,也是尴尬); 1. 前提工作你目前的 iOS 项目已经是 ReactNative 混合 App;这边我用我之前的来做,具体代码可以看这个链接(国内Coding)或者这个链接(国外github); 2. 了解一些 codepush 的原理之前在 CSDN 写的 codepush 相关的博客 CodePush 热更新ReactNative之CodePush CLI操作 CodePush 热更新ReactNative之React Native Client SDK 可以看下了解,当然最好去官方 gayhub 去看文档比较好; 按照文档吧 codepush 的环境安装好👌; 3. 集成进入 App 项目里 安装 codepush 模块 npm install --save react-native-code-push@latest; 在安装完成后,可以执行命令自动导包进去 react-native link react-native-code-push, 当然也可以手动导包,自己看下官方文档;在自动导包时,会要求你添加 codepush 的 key, 可以跳过下面会说到怎么添加; 到此就可以看到 package.json 里面多了一个模块;目录变化 原生项目文件变化,添加了 CodePush 工程,还有一些静态库,至于 AppDelegate.m 里面的好像是会有,有点忘记了; 4. 配置 codepush 的 key codepush 创建 app code-push app add MyApp-iOS 会从中得到一个 key ,复制这个 key ,下一步在 iOS 原生中会用到; iOS中原生配置 key ,在 Info.plist 文件中,如下图; 5. 原生代码配置 AppDelegate.m 文件中配置,为了一进入 App 就加载好了, codepush 环境,我个人认为的,没有去测试; 在每处用到混合的地方加入代码,这边我用到了两处,所以两个的 .m 文件中,我都加入类似的代码; 6. js 代码的配置js 基本的配置就是这些,具体的有些配置,可以官方文档看下; 7. iOS 打 release 包 在 js 主目录下,执行命令 curl http://localhost:8081/index.ios.bundle -o main.jsbundle 会在目录下有个 main.jsbundle 的文件,这个需要拖到 iOS 原生目录下,每次打包重新生成,都需要替换进去; iOS 打包 ipa 包,只要把刚才的 main.jsbundle 拖进去,剩下的步骤和正常打包一样;8. 打 codepush 更新包在 js 的目录下,执行命令 code-push release-react youAppName ios, 最简单命令,直接推到Staging; 9. 到此基本结束,根据你设置的更新条件, App 就会自动更新了;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-with-ReactNative]]></title>
    <url>%2F2016%2F12%2F28%2FiOS-with-ReactNative%2F</url>
    <content type="text"><![CDATA[如何在现有的iOS项目中添加ReactNative混合开发如果公司的项目之前是用原生, 现在想做混合开发并且选择ReactNative, 这篇会是一个基础的环境配置; 1. 开发环境准备首先, 至少你已经搭建了 React Native 的开发环境在iOS平台上所需的一切依赖软件（比如npm）。 其次, CocoaPods 包管理工具, 基本做iOS开发都有装, 如果没有, 那就百度一下😂; 2. 安装依赖包React Native的植入过程同时需要React和React Native两个node依赖包。在你的原有的iOS目录的上一级目录创建一个包管理package.json文件; 对于一个典型的React Native项目来说，一般package.json和index.ios.js等文件会放在项目的根目录下。而iOS相关的原生代码会放在一个名为ios/的子目录中,这里也同时放着你的Xcode项目文件（.xcodeproj）。 123456789101112131415// package.json 文件内容&#123; &quot;name&quot;: &quot;NumberTileGame&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;react&quot;: &quot;15.4.1&quot;, &quot;react-native&quot;: &quot;0.39.2&quot; &#125;&#125;// 通过npm info react和npm info react-native 来查看当前的最新版本 npm install // 在 package.json 的当前目录下开启终端执行这段代码, 这些模块就会安装到 node_modules/ 下; 3. React Native框架嵌入iOSSubspecs在你开始把React Native植入到你的应用中之前，首先要决定具体整合的是React Native框架中的哪些部分。而这就是subspec要做的工作。在创建Podfile文件的时候，需要指定具体安装哪些React Native的依赖库。所指定的每一个库就称为一个subspec。 可用的subspec都列在node_modules/react-native/React.podspec中，基本都是按其功能命名的。一般来说你首先需要添加Core，这一subspec包含了必须的AppRegistry、StyleSheet、View以及其他的一些React Native核心库。如果你想使用React Native的Text库（即组件），那就需要添加RCTText的subspec。同理，Image需要加入RCTImage，等等。 Podfile在 CocoaPods 的 Podfile 中指定我们所需要使用的组件。如果原生没有用过 CocoaPods 管理; //在iOS原生代码所在的目录中（也就是.xcodeproj文件所在的目录）执行： pod init Podfile 会创建在执行命令的目录中。你需要调整其内容以满足你的植入需求。调整后的Podfile的内容看起来类似下面这样： 1234567891011121314# target的名字一般与你的项目名字相同target &apos;NumberTileGame&apos; do # &apos;node_modules&apos;目录一般位于根目录中 # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path` pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTNetwork&apos;, &apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的 # 在这里继续添加你所需要的模块 ]end Pod安装创建好了Podfile后，就可以开始安装React Native的pod包了。 pod install 4. 代码集成原生代码集成在要混合开发的页面, 加入如下代码 1234567891011// RNViewController 页面- (void)viewDidLoad &#123; [super viewDidLoad]; NSURL *jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios"]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL : jsCodeLocation moduleName : @"HybridApp" initialProperties : @&#123;@"page" : @"RN1"&#125; // 传入参数,用于定义那个页面或者一些数据传输 launchOptions : nil]; self.view = rootView;&#125; ReactNative代码集成index.ios.js js 代码的入口 12345'use strict';import &#123;AppRegistry&#125; from 'react-native';import App from './app';AppRegistry.registerComponent('HybridApp', () =&gt; App);// 注册模块 app.js 在这边做页面判断,当然你也可以根据自己的需求去做调整 12345678910111213'use strict';import React from 'react';import RN1 from './ReactNative1';import RN2 from './ReactNative2';export default class App extends React.Component &#123; render() &#123; return ( this.props['page'] == 'RN1' ? &lt;RN1 /&gt;:&lt;RN2 /&gt; ); &#125;&#125; ReactNative1.js 页面1 12345678910111213141516171819202122232425262728293031'use strict';import React from 'react';import &#123; StyleSheet, Text, View&#125; from 'react-native';export default class ReactNative1 extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.highScoresTitle&#125;&gt;ReactNative1&lt;/Text&gt; &lt;View style=&#123;&#123;height: 100, width: 100, backgroundColor: 'blue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#FFFFFF', &#125;, highScoresTitle: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;&#125;); ReactNative2.js 页面2 123456789101112131415161718192021222324252627282930'use strict';import React from 'react';import &#123; StyleSheet, Text, View&#125; from 'react-native';export default class ReactNative1 extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.highScoresTitle&#125;&gt;ReactNative2&lt;/Text&gt; &lt;View style=&#123;&#123;height: 100, width: 100, backgroundColor: 'red'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#FFFFFF', &#125;, highScoresTitle: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;&#125;); &gt;&gt;项目gayhub地址&lt;&lt;效果展示]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-Func]]></title>
    <url>%2F2016%2F12%2F14%2FJavaScript-Func%2F</url>
    <content type="text"><![CDATA[函数 function 基本上所有的高级语言都支持函数，JavaScript也不例外。JavaScript的函数不但是“头等公民”，而且可以像变量一样使用，具有非常强大的抽象能力。函数就是最基本的一种代码抽象的方式1. 函数的定义和调用1234567891011121314151617181920212223242526272829303132333435363738394041424344// 定义函数方式1function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;function指出这是一个函数定义；abs是函数的名称；(x)括号内列出函数的参数，多个参数以,分隔；&#123; ... &#125;之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。// 定义函数方式2var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;;在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。// 调用函数abs(10); // 返回10// JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数abs(10, 'blablabla'); // 返回10// 传入的参数比定义的少也没有问题abs(); // 返回NaN// 要避免收到undefined，可以对参数进行检查function abs(x) &#123; if (typeof x !== 'number') &#123; throw 'Not a number'; &#125; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; 2. arguments1234567891011121314151617181920function abs() &#123; if (arguments.length === 0) &#123; return 0; &#125; var x = arguments[0]; return x &gt;= 0 ? x : -x;&#125;abs(); // 0abs(10); // 10// 实际上arguments最常用于判断传入参数的个数// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) &#123; if (arguments.length === 2) &#123; // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 &#125; // ...&#125; 3. rest参数(ES6)1234567891011121314151617function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 4. 变量作用域12345678910// 两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响'use strict';function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125;// JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 5. 变量提升// JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部 1234567'use strict';function foo() &#123; var x = 'Hello, ' + y; alert(x); var y = 'Bob';&#125;foo(); 6. 全局作用域// 不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性 1234'use strict';var course = 'Learn JavaScript';alert(course); // 'Learn JavaScript'alert(window.course); // 'Learn JavaScript' 7. 名字空间// 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。— 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。 123456789// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 8. 局部作用域(ES6 let)123456789101112131415'use strict';function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125;// 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; i += 1; // SyntaxError&#125; 9. 常量(ES6 const)ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： 12345'use strict';const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 10. 方法对象中绑定函数, 称为这个对象的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了var fn = xiaoming.age;fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined 并没有解决this应该指向的正确位置function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN// 单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。JavaScript的函数内部如果调用了this，那么这个this到底指向谁？// 修复的办法:我们用一个that变量首先捕获thisvar xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 11. apply call 可以控制this的指向的123456789101112131415161718function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空apply()把参数打包成Array再传入；call()把参数按顺序传入。Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 12. 装饰器利用apply()，我们还可以动态改变函数的行为;JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。 现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()： 1234567891011var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123; count += 1; return oldParseInt.apply(null, arguments); // 调用原函数&#125;;// 测试:parseInt('10');parseInt('20');parseInt('30');count; // 3 13. 函数作为返回值1234567891011121314151617function sum(arr) &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;);&#125;sum([1, 2, 3, 4, 5]); // 15// 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125;var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()f(); // 15]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-Map-Set]]></title>
    <url>%2F2016%2F12%2F13%2FJavaScript-Map-Set%2F</url>
    <content type="text"><![CDATA[1. Map(ES6) 是一组键值对的结构，具有极快的查找速度。12345678910111213141516var m1 = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m1.get('Michael'); // 95var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined// 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 2. Set(ES6) 一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key123456789101112131415var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3// 重复元素在Set中自动被过滤var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, "3"&#125;// add(key) 方法可以添加元素到Set中, 可以重复添加，但不会有效果s.add(4)s // &#123;1, 2, 3, 4&#125;s.add(4)s // &#123;1, 2, 3, 4&#125;// delete(key)方法可以删除元素s.delete(3);s; // Set &#123;1, 2&#125; 3. iterable ES6标准引入了新的iterable类型, Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for … of循环来遍历123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array alert(x);&#125;for (var x of s) &#123; // 遍历Set alert(x);&#125;for (var x of m) &#123; // 遍历Map alert(x[0] + '=' + x[1]);&#125; 你可能会有疑问，for ... of 循环和 for ... in 循环有何区别？for ... in 循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性 1234567891011var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; alert(x); // '0', '1', '2', 'name'&#125;for ... in循环将把name包括在内，但Array的length属性却不包括在内。for ... of循环则完全修复了这些问题，它只循环集合本身的元素for (var x of a) &#123; alert(x); // 'A', 'B', 'C'&#125; 更好的方式是直接使用 iterable 内置的 forEach 方法，它接收一个函数，每次迭代就自动回调该函数 12345678910111213141516171819202122var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 alert(element);&#125;);// Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; alert(element);&#125;);// Map的回调函数参数依次为value、key和map本身var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; alert(value);&#125;);//如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的elementvar a = ['A', 'B', 'C'];a.forEach(function (element) &#123; alert(element);&#125;);]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Map</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-Object]]></title>
    <url>%2F2016%2F12%2F13%2FJavaScript-Object%2F</url>
    <content type="text"><![CDATA[对象的操作1. 对象的定义对象是一种无序的集合数据类型，它由若干键值对组成。JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他 12345678910111213141516171819202122232425262728293031323334var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;xiaoming.name; // '小明'xiaoming.birth; // 1990var xiaohong = &#123; name: '小红', 'middle-school': 'No.1 Middle School' // 如果属性名包含特殊字符，就必须用''括起来&#125;;xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红'xiaohong.age; // undefined访问不存在的属性不报错，而是返回undefined'name' in xiaohong; // true'grade' in xiaohong; // false// 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：var xiaoming = &#123; name: '小明'&#125;;// 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-Array]]></title>
    <url>%2F2016%2F12%2F13%2FJavaScript-Array%2F</url>
    <content type="text"><![CDATA[数组的学习和操作1. 数组的定义JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 1234567891011var arr = [1, 2, 3];arr.length; // 3 获取长度arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2]arr.length = 0; // 清空数组arr[1] = 99; // 通过索引把对应的元素修改为新的值// 索引超过了范围，同样会引起Array大小的变化arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 2. 操作数组2.1 indexOf 搜索一个指定的元素的位置12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 2.2 slice 切片,对应String的substring()版本,截取1234567var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false 2.3 push 向Array的末尾添加若干元素，pop 则把Array的最后一个元素删除掉123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] 2.4 unshift 头部添加若干元素, shift 则把Array的第一个元素删掉123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] 2.5 sort 对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] 2.6 reverse 反转整个Array的元素123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] 2.7 splice 可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。splice(index,howmany,item1,…..,itemX)splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 返回值 类型 描述 Array 包含被删除项目的新数组，如果有的话。 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] 2.8 concat 把当前的Array和另一个Array连接起来，并返回一个新的Array1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 2.9 join 把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接 2.10 多维数组1var arr = [[1, 2, 3], [400, 500, 600], '-']; 2.11 map 和 reduce1234567891011121314151617181920var pow = function (item,index,list) &#123; return item * item;&#125;;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]// map()作为高阶函数，事实上它把运算规则抽象了arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']// 把Array的所有数字转为字符串 array1.reduce(callbackfn, initialValue)// array1: 必需。一个数组对象。// initialValue: 可选。如果指定 initialValue，则它将用作初始值来启动累积。第一次调用 callbackfn 函数会将此值作为参数而非数组值提供。// callbackfn: 必需。一个接受最多四个参数的函数。对于数组中的每个元素，reduce 方法都会调用 callbackfn 函数一次。function callbackfn(previousValue, currentValue, currentIndex, array1)// previousValue: 通过上一次调用回调函数获得的值。如果向 reduce 方法提供 initialValue，则在首次调用函数时，previousValue 为 initialValue。// currentValue: 当前数组元素的值。// currentIndex: 当前数组元素的数字索引。// array1: 包含该元素的数组对象。 2.12 filter 过滤,它用于把Array的某些元素过滤掉，然后返回剩下的元素,根据返回值是true还是false决定保留还是丢弃该元素1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;); 2.13 sort 排序123456789101112131415161718192021// 看上去正常的结果:['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];// apple排在了最后:['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']// 无法理解的结果:[10, 20, 1, 2].sort(); // [1, 10, 2, 20]// 第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。// 第三个排序结果是什么鬼？简单的数字排序都能错？这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果'10'排在了'2'的前面，因为字符'1'比字符'2'的ASCII码小// sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); // [1, 2, 10, 20]// sort()方法会直接对Array进行修改，它返回的结果仍是当前Array]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
        <tag>数组操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-String]]></title>
    <url>%2F2016%2F12%2F13%2FJavaScript-String%2F</url>
    <content type="text"><![CDATA[字符串学习操作1. 字符串定义‘字符串’ 和 “字符串” 字符串用单引号和双引号表示, 不过要同样的成对出现;如果 &#39; 本身也是一个字符，那就可以用 &quot;&quot; 括起来 &quot;I&#39;m OK&quot; 如果字符串内部既包含 &#39; 又包含 &quot; 怎么办？可以用转义字符\来标识; 1'I\'m \"OK\"!'; 2. 模板字符串, 多行字符串(ES6 标准)ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： 123456var str = `这是一个多行字符串`;var name = '小明';var age = 20;alert(`你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`); 3. 操作字符串1234567var s = 'Hello, world!';s.length; // 13//要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始;s[0]; // 'H's[7]; // 'w's[13]; // undefined 超出范围的索引不会报错，但一律返回undefined// 字符串不可改变 3.1 toUpperCase 字符串全部变大写toLowerCase 字符串全部变小写123var s = 'Hello';s.toUpperCase(); // 返回'HELLO's.toLowerCase(); // 返回'hello' 3.2 indexOf会搜索指定字符串出现的位置：123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 3.3 substring 返回指定索引区间的子串123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world']]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>String</tag>
        <tag>字符串操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾Hexo]]></title>
    <url>%2F2016%2F12%2F12%2FHexo%20%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Hexo 博客的安装流程1. 配置环境因为本人是用 Mac 所以就以主要介绍 Mac 的环境为主; 1.1 安装 Node 环境 作用：用来生成静态页面的 方法1. 直接上 https://nodejs.org/ 官网下载安装 方法2. Homebrew 安装Homebrew 是 Mac 系统的包管理器，用于安装 NodeJS 和一些其他必需的工具软件。 首先, 安装 Homebrew; 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 复制上面代码在终端里面运行,等待安装完毕; 接下来在用 Homebrew 安装 Node; 1brew install node 复制上面代码在终端里面运行,等待安装完毕; 1.2 Github 或者 Coding 账户都可以 作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 2. 正式安装 Hexo2.1 安装 Hexo 的命令行工具1npm install -g hexo 复制上面代码在终端里面运行,等待安装完毕; 2.2 初始化博客1hexo init 你的博客名 在终端中前往你要放置博客的文件夹位置, 运行上面代码,等待安装完毕; 2.3 配置 Github 仓库登录到你自己的 github 账号, 点击 new repository 开始创建仓库, 按照下面的填写你自己要的参数;配置 github pages 页面, 点击 Settings , 在 GitHub Pages 中开启配置为主分支 2.4 配置 Hexo 文件打开 Hexo 创建的根目录下的 _config.yml 文件,主要配置如下 1234567# Sitetitle: you blog // 你博客的名称标题subtitle: // 你博客的小标题(选填)description: 好好过一生 // 博客的描述,可以写短小的座右铭author: FerryVip // 作者你的名字language: zh-Hans // 设置博客的语音(选填,默认英文)timezone: // 时区(选填) 12345# Deploymentdeploy: type: git // 类型就填 git repo: git@github.com:strawferry/FerryBlog.git // 你的仓库地址,在配置 github 仓库成功后会有,可以用 HTTPS (需要输入密码登录)和 SSH(需要配置SSH) branch: master // 默认主分支 1npm install hexo-deployer-git --save 复制上面代码在终端的 hexo 目录下里面运行,等待安装完毕; 2.5 node 生成静态文件 hexo generate 或者 hexo g 复制上面代码在终端的 hexo 目录下里面运行,等待运行完毕; 2.6 本地运行查看123hexo server或者 hexo s 复制上面代码在终端的 hexo 目录下里面运行,等待运行完毕, 显示通过访问 http://localhost:4000/ 就可以预览博客; 2.6 上传博客文件到 github123hexo deploy或者 hexo d 复制上面代码在终端的 hexo 目录下里面运行,等待运行完毕;等待运行完毕基本就能访问刚才在 github 配置 pages 的链接了; 2.7 编写你的博客1hexo new "new article" 之后在source/_posts目录下面，多了一个new-article.md的文件。你通过编辑 new-article.md 就可以写你的日记了; 2.8 一些常用的命令 hexo clean // 清除文件 hexo generate // 生成静态文件 hexo deploy // 部署代码上去 hexo new &quot;文章标题&quot; // 创建新文章 3. 配置 Hexo 主题官方默认主题你懂得,不怎么好看,果断自己换个,本人觉得 next 的主题还可以,这边就以配置这个主题举个栗子;官方使用文档 主题下载 git clone https://github.com/iissnan/hexo-theme-next themes/next 复制上面代码在终端的 hexo 目录下里面运行,等待下载完毕; 主题更改 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape // 改为 next 到此基本配置 Hexo 和 主题更换已经都会了,要更好使用,还需要自己看下文档去详细配置;说说之前配置遇到的一个坑, 前面我没有说到,就是要等大家都配置完了,大伙也会碰到的问题,在最后给大家说一下 就是在本地跑 hexo server 一切看起来都好好的,样式都没啥问题, 当去看 pages 的时候,发现样式惨不忍睹,这就对了,因为还有一个东西还没有配置; 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.com // 把你在 pages 配置的那个网址链接复制在这个地方就解决了root: /permalink: :year/:month/:day/:title/permalink_defaults:]]></content>
      <tags>
        <tag>hexo配置</tag>
      </tags>
  </entry>
</search>
